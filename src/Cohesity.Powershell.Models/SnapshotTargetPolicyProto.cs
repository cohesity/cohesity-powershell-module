// Copyright 2019 Cohesity Inc.

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace Cohesity.Model
{
    /// <summary>
    /// Message that specifies the policy for copying backup snapshots to a target. This message also specifies the retention policy that should be applied to the snapshots after they have been copied to the specified target.
    /// </summary>
    [DataContract]
    public partial class SnapshotTargetPolicyProto :  IEquatable<SnapshotTargetPolicyProto>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SnapshotTargetPolicyProto" /> class.
        /// </summary>
        /// <param name="backupType">The backup type for which copy will be made to the snapshot target. If set, the first run of given type during the scheduled period will get copied.  Currently, the only value that can be set here is kFull (Magneto will return an error if it is set to anything else)..</param>
        /// <param name="copyBackupTimeoutVec">This is a vector of timeouts, specified by the user, for different backup types(kFull, kRegular). A cancellation will automatically gets triggered if the copy task/sub-task has been running for more than this timeout duration..</param>
        /// <param name="copyPartiallySuccessfulRun">If this is false, then only snapshots from the first completely successful run in the given time granularity will be considered for being copied. If this is true, then snapshots from the first partially successful run will also be eligible to be copied..</param>
        /// <param name="extendedRetentionPolicyVec">Specifies additional retention policies that should be applied to the copy snapshot. A copy snapshot will be retained up to a time that is the maximum of all retention policies that are applicable to it..</param>
        /// <param name="granularityBucket">granularityBucket.</param>
        /// <param name="id">This id uniquely identifies this entry in the ProtectionPolicyProto.  If this message is from global policy, this id is generated by Helios. Otherwise, it is generated by Iris. Magneto uses this for merging linked policies with its parent global policy..</param>
        /// <param name="logRetentionPolicy">logRetentionPolicy.</param>
        /// <param name="numDaysToKeep">Specifies how to determine the expiration time for snapshots copied due to this policy. The snapshots will be marked as expiring (i.e., eligible to be garbage collected) in &#39;num_days_to_keep&#39; days from when the snapshots were created..</param>
        /// <param name="retentionPolicy">retentionPolicy.</param>
        /// <param name="snapshotTarget">snapshotTarget.</param>
        public SnapshotTargetPolicyProto(int? backupType = default(int?), List<CancellationTimeout> copyBackupTimeoutVec = default(List<CancellationTimeout>), bool? copyPartiallySuccessfulRun = default(bool?), List<ExtendedRetentionPolicyProto> extendedRetentionPolicyVec = default(List<ExtendedRetentionPolicyProto>), GranularityBucket granularityBucket = default(GranularityBucket), string id = default(string), RetentionPolicyProto logRetentionPolicy = default(RetentionPolicyProto), long? numDaysToKeep = default(long?), RetentionPolicyProto retentionPolicy = default(RetentionPolicyProto), SnapshotTarget snapshotTarget = default(SnapshotTarget))
        {
            this.BackupType = backupType;
            this.CopyBackupTimeoutVec = copyBackupTimeoutVec;
            this.CopyPartiallySuccessfulRun = copyPartiallySuccessfulRun;
            this.ExtendedRetentionPolicyVec = extendedRetentionPolicyVec;
            this.Id = id;
            this.NumDaysToKeep = numDaysToKeep;
            this.BackupType = backupType;
            this.CopyBackupTimeoutVec = copyBackupTimeoutVec;
            this.CopyPartiallySuccessfulRun = copyPartiallySuccessfulRun;
            this.ExtendedRetentionPolicyVec = extendedRetentionPolicyVec;
            this.GranularityBucket = granularityBucket;
            this.Id = id;
            this.LogRetentionPolicy = logRetentionPolicy;
            this.NumDaysToKeep = numDaysToKeep;
            this.RetentionPolicy = retentionPolicy;
            this.SnapshotTarget = snapshotTarget;
        }
        
        /// <summary>
        /// The backup type for which copy will be made to the snapshot target. If set, the first run of given type during the scheduled period will get copied.  Currently, the only value that can be set here is kFull (Magneto will return an error if it is set to anything else).
        /// </summary>
        /// <value>The backup type for which copy will be made to the snapshot target. If set, the first run of given type during the scheduled period will get copied.  Currently, the only value that can be set here is kFull (Magneto will return an error if it is set to anything else).</value>
        [DataMember(Name="backupType", EmitDefaultValue=true)]
        public int? BackupType { get; set; }

        /// <summary>
        /// This is a vector of timeouts, specified by the user, for different backup types(kFull, kRegular). A cancellation will automatically gets triggered if the copy task/sub-task has been running for more than this timeout duration.
        /// </summary>
        /// <value>This is a vector of timeouts, specified by the user, for different backup types(kFull, kRegular). A cancellation will automatically gets triggered if the copy task/sub-task has been running for more than this timeout duration.</value>
        [DataMember(Name="copyBackupTimeoutVec", EmitDefaultValue=true)]
        public List<CancellationTimeout> CopyBackupTimeoutVec { get; set; }

        /// <summary>
        /// If this is false, then only snapshots from the first completely successful run in the given time granularity will be considered for being copied. If this is true, then snapshots from the first partially successful run will also be eligible to be copied.
        /// </summary>
        /// <value>If this is false, then only snapshots from the first completely successful run in the given time granularity will be considered for being copied. If this is true, then snapshots from the first partially successful run will also be eligible to be copied.</value>
        [DataMember(Name="copyPartiallySuccessfulRun", EmitDefaultValue=true)]
        public bool? CopyPartiallySuccessfulRun { get; set; }

        /// <summary>
        /// Specifies additional retention policies that should be applied to the copy snapshot. A copy snapshot will be retained up to a time that is the maximum of all retention policies that are applicable to it.
        /// </summary>
        /// <value>Specifies additional retention policies that should be applied to the copy snapshot. A copy snapshot will be retained up to a time that is the maximum of all retention policies that are applicable to it.</value>
        [DataMember(Name="extendedRetentionPolicyVec", EmitDefaultValue=true)]
        public List<ExtendedRetentionPolicyProto> ExtendedRetentionPolicyVec { get; set; }

        /// <summary>
        /// Gets or Sets GranularityBucket
        /// </summary>
        [DataMember(Name="granularityBucket", EmitDefaultValue=false)]
        public GranularityBucket GranularityBucket { get; set; }

        /// <summary>
        /// This id uniquely identifies this entry in the ProtectionPolicyProto.  If this message is from global policy, this id is generated by Helios. Otherwise, it is generated by Iris. Magneto uses this for merging linked policies with its parent global policy.
        /// </summary>
        /// <value>This id uniquely identifies this entry in the ProtectionPolicyProto.  If this message is from global policy, this id is generated by Helios. Otherwise, it is generated by Iris. Magneto uses this for merging linked policies with its parent global policy.</value>
        [DataMember(Name="id", EmitDefaultValue=true)]
        public string Id { get; set; }

        /// <summary>
        /// Gets or Sets LogRetentionPolicy
        /// </summary>
        [DataMember(Name="logRetentionPolicy", EmitDefaultValue=false)]
        public RetentionPolicyProto LogRetentionPolicy { get; set; }

        /// <summary>
        /// Specifies how to determine the expiration time for snapshots copied due to this policy. The snapshots will be marked as expiring (i.e., eligible to be garbage collected) in &#39;num_days_to_keep&#39; days from when the snapshots were created.
        /// </summary>
        /// <value>Specifies how to determine the expiration time for snapshots copied due to this policy. The snapshots will be marked as expiring (i.e., eligible to be garbage collected) in &#39;num_days_to_keep&#39; days from when the snapshots were created.</value>
        [DataMember(Name="numDaysToKeep", EmitDefaultValue=true)]
        public long? NumDaysToKeep { get; set; }

        /// <summary>
        /// Gets or Sets RetentionPolicy
        /// </summary>
        [DataMember(Name="retentionPolicy", EmitDefaultValue=false)]
        public RetentionPolicyProto RetentionPolicy { get; set; }

        /// <summary>
        /// Gets or Sets SnapshotTarget
        /// </summary>
        [DataMember(Name="snapshotTarget", EmitDefaultValue=false)]
        public SnapshotTarget SnapshotTarget { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString() { return ToJson(); }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as SnapshotTargetPolicyProto);
        }

        /// <summary>
        /// Returns true if SnapshotTargetPolicyProto instances are equal
        /// </summary>
        /// <param name="input">Instance of SnapshotTargetPolicyProto to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(SnapshotTargetPolicyProto input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.BackupType == input.BackupType ||
                    (this.BackupType != null &&
                    this.BackupType.Equals(input.BackupType))
                ) && 
                (
                    this.CopyBackupTimeoutVec == input.CopyBackupTimeoutVec ||
                    this.CopyBackupTimeoutVec != null &&
                    input.CopyBackupTimeoutVec != null &&
                    this.CopyBackupTimeoutVec.SequenceEqual(input.CopyBackupTimeoutVec)
                ) && 
                (
                    this.CopyPartiallySuccessfulRun == input.CopyPartiallySuccessfulRun ||
                    (this.CopyPartiallySuccessfulRun != null &&
                    this.CopyPartiallySuccessfulRun.Equals(input.CopyPartiallySuccessfulRun))
                ) && 
                (
                    this.ExtendedRetentionPolicyVec == input.ExtendedRetentionPolicyVec ||
                    this.ExtendedRetentionPolicyVec != null &&
                    input.ExtendedRetentionPolicyVec != null &&
                    this.ExtendedRetentionPolicyVec.SequenceEqual(input.ExtendedRetentionPolicyVec)
                ) && 
                (
                    this.GranularityBucket == input.GranularityBucket ||
                    (this.GranularityBucket != null &&
                    this.GranularityBucket.Equals(input.GranularityBucket))
                ) && 
                (
                    this.Id == input.Id ||
                    (this.Id != null &&
                    this.Id.Equals(input.Id))
                ) && 
                (
                    this.LogRetentionPolicy == input.LogRetentionPolicy ||
                    (this.LogRetentionPolicy != null &&
                    this.LogRetentionPolicy.Equals(input.LogRetentionPolicy))
                ) && 
                (
                    this.NumDaysToKeep == input.NumDaysToKeep ||
                    (this.NumDaysToKeep != null &&
                    this.NumDaysToKeep.Equals(input.NumDaysToKeep))
                ) && 
                (
                    this.RetentionPolicy == input.RetentionPolicy ||
                    (this.RetentionPolicy != null &&
                    this.RetentionPolicy.Equals(input.RetentionPolicy))
                ) && 
                (
                    this.SnapshotTarget == input.SnapshotTarget ||
                    (this.SnapshotTarget != null &&
                    this.SnapshotTarget.Equals(input.SnapshotTarget))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.BackupType != null)
                    hashCode = hashCode * 59 + this.BackupType.GetHashCode();
                if (this.CopyBackupTimeoutVec != null)
                    hashCode = hashCode * 59 + this.CopyBackupTimeoutVec.GetHashCode();
                if (this.CopyPartiallySuccessfulRun != null)
                    hashCode = hashCode * 59 + this.CopyPartiallySuccessfulRun.GetHashCode();
                if (this.ExtendedRetentionPolicyVec != null)
                    hashCode = hashCode * 59 + this.ExtendedRetentionPolicyVec.GetHashCode();
                if (this.GranularityBucket != null)
                    hashCode = hashCode * 59 + this.GranularityBucket.GetHashCode();
                if (this.Id != null)
                    hashCode = hashCode * 59 + this.Id.GetHashCode();
                if (this.LogRetentionPolicy != null)
                    hashCode = hashCode * 59 + this.LogRetentionPolicy.GetHashCode();
                if (this.NumDaysToKeep != null)
                    hashCode = hashCode * 59 + this.NumDaysToKeep.GetHashCode();
                if (this.RetentionPolicy != null)
                    hashCode = hashCode * 59 + this.RetentionPolicy.GetHashCode();
                if (this.SnapshotTarget != null)
                    hashCode = hashCode * 59 + this.SnapshotTarget.GetHashCode();
                return hashCode;
            }
        }

    }

}

